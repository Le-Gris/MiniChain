# Prompt from ...
#
from dataclasses import dataclass

from parsita import TextParsers, lit, reg

from minichain import Backend, JinjaPrompt, SimplePrompt, start_chain


# Define the states of the bot.
@dataclass
class IntermediateState:
    s: str
@dataclass
class FinalState:
    s: str
States = FinalState | IntermediateState


class Pal(JinjaPrompt[States]):
    template_file = "pal.pmpt.tpl"


    def parse(self, inp: str) -> States:
        return self.SelfAskParser.response.parse(inp).or_die()  # type: ignore

SelfAsk().show({"input": "What is the zip code of the city where George Washington was born?",
                "agent_scratchpad":True},
               "Follow up: Where was George Washington born?")

    

def selfask(inp: str, openai: Backend, google: Backend) -> str:
    prompt1 = SelfAsk(openai)
    prompt2 = SimplePrompt(google)
    suffix = ""
    for i in range(3):
        r1 = prompt1(
            dict(input=inp, suffix=suffix, agent_scratchpad=True), name=f"Chat {i}"
        )
        if isinstance(r1.val, FinalState):
            break
        out = prompt2(r1.val.s, name=f"Google{i}")
        suffix += "\nIntermediate answer:" + out.echo
    return r1.val.s


with start_chain("pal") as backend:
    result = pal(
        "What is the zip code of the city where George Washington was born?",
        backend.Mock(
            [
                "Follow up: Where was George Washington born?",
                "Follow up: What is the zip code of Virginia?",
                "So the final answer is: 12312",
            ]
        ),
        # OpenAI("")
        backend.Mock(["Virginia", "12312"]),
    )
print(result)

!eliot-tree -l 0 selfask.log | grep -v "succeeded" | grep -v "started"
    
